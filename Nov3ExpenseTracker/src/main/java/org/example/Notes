SDLC - Iterative Methodology
Agile Methodology
Planning -> Design -> Implementation -> Testing -> Deployment -> Monitor/Maintain -> Restart Cycle
    Cycle will end when customer says dont change anything else or project meets end of life
Agile is designed to be flexible
    If we find new feature to be added, we can put it through the cycle. Sprint = 1 Cycle.
MVP - Minimum Valuable Product
    This can be a small product that we know we are going to expand upon later.


Linear Model- Waterfall
Planning -> Design -> Implementation -> Testing -> Deployment -> Monitor/Maintain
    You completely finish one before you start the next


"As a " ______ (who)                     As a user
"I want to " ______ (what)      ->       I want to track my responses
"So that " _______ (why)                 So that I can build/submit an expense report at the end of the week.

- As a user, I want to track my responses soo that I can build/submit an expense report at the end of the week.
- As a user, I need to include the date, value, and merchant to include on my expense report.

Application/Launcher/Driver
- App
Model
- Expense
    - id
    - date
    - value
    - merchant


writer.flush(); //this takes it form the buffer to the file (flushing it from the buffer to the file)

JSON
We can do more than CSV we can play with objects (really complex objects if we want)
JSON leverages key: value

{ [ { //this is the beginning of the object. Use this as a grouping symbol
    id:1,
    date:Mon Nov 03 CST 2025,
    value:99.95,
    merchant:"Walmart"
    },
    {
    --
    --
    --
    --
    },]
//adding multiple bracket groups will make it a list

Versioning can show you how long something has been in production
2.10.1
2- Major-Breaking Changes
10- Minor-Non-Breaking
1- Patch - Bug Fixes
if they are in patch 17 with minor version 1 something is wrong


Main[
    -Vars                           Repository
    try[ -  to txt                   ExpTxt
       |    to csv                   ExpCSV
       |    to JSON                  ExpJSON
    catch[
For each of the external formats we can create a repository class


//Using an Interface it would define the methods that will:
read from the file and when we are done reading from the file we will get a list of expenses
void method that will write to the file and it needs to accept that list of expenses
Now main method doesnt care what we are reading
Main[
    -Vars
    IRepository

List<E>ReadFile()
void writefile(List<Expense>)


Deserializing taking content and turning it back into an object (that list)

Driver/Launcher
-Main ->
         Service(layer) ->
                           Repo(layer)

